---
name: python-code-quality
description: Follow clean code principles for readability, maintainability, and Python conventions.
globs:
  - "src/**/*.py"
  - "tests/**/*.py"
alwaysApply: true
---

## Code Quality Rules

- **Avoid hard-coded numbers**: Use named constants for magic numbers (e.g., `SALES_TAX_RATE = 0.08` instead of `price * 0.08`).

- **Use meaningful, descriptive names**: Names should explain purpose without needing comments (e.g., `elapsed_days = 12` instead of `d = 12`).

- **Use comments sparingly**: Code should be clear enough to read without comments. Only comment to explain *why* something unusual is happening, not *what* the code does.

- **Document complex interfaces**: For complex functions or classes, use structured docstrings with **Args**, **Returns**, and **Raises** sections. This creates a clear "contract" so users don't need to read implementation logic. See `@python-type-safety.mdc` for type hints that complement docstrings.

- **Follow Python conventions**: Use `snake_case` for functions and variables, `PascalCase` for classes. Follow PEP 8 style guidelines.

- **Encapsulate nested conditionals**: Deeply nested `if/else` blocks are hard to read. Extract the logic into a helper function with a descriptive name (e.g., `if should_grant_access(user):` instead of nested conditionals).

- **Single Responsibility**: See `@python-reuse-first.mdc` for SRP guidance on when to split functions/modules.

## Naming Conventions

- **Language:** 100% English for variable names, functions, classes
- **snake_case:** variables, functions (`user_id`, `calculate_total`)
- **PascalCase:** Classes (`UserController`, `TrainingExecutor`)
- **SCREAMING_SNAKE_CASE:** Constants (`MAX_RETRY`, `DEFAULT_BATCH_SIZE`)
- **Boolean:** prefix with `is`, `has`, `can`, `should` (`is_valid`, `has_data`, `can_process`)

✅ `customer_address`, `is_valid`, `fetch_user_data()`  
❌ `addr`, `val`, `func1()`

## Function & Logic Flow

- **Early Return:** Avoid deep if/else nesting, return early
- **Single Responsibility:** 1 function = 1 task
- **Max 30-50 lines/function** (recommended)
- **Max 3 parameters**, use `TypedDict` or `dataclass` if more needed

```python
# ✅ Good - Early return, clear flow
def process_order(order: Order) -> bool:
    if not order:
        return False
    if not order.is_valid:
        return False
    return execute_transaction(order)

# ❌ Bad - Arrow code (deep nesting)
def process_order(order: Order) -> bool:
    if order:
        if order.is_valid:
            return execute_transaction(order)
    return False
```

## Type Safety

- **No Magic Numbers:** ❌ `if status == 1:` ✅ `if status == OrderStatus.PENDING:`
- **Strict Typing:** Declare types for params and return values (see `@python-type-safety.mdc`)
- **Immutability:** Prefer creating copies instead of mutating data (especially for ML data structures)

```python
# ✅ Good - Named constants
class OrderStatus:
    PENDING = 1
    PROCESSING = 2
    COMPLETED = 3

if order.status == OrderStatus.PENDING:
    process_order(order)

# ❌ Bad - Magic numbers
if order.status == 1:
    process_order(order)
```

## Error Handling

- **Don't swallow errors:** Always log in `try/except` blocks
- **Structured Logging:** Use structured logging with context (see `src/training/logging.py`)
- **Fail Fast:** Report errors immediately when serious issues are detected
- **Specific exceptions:** Catch specific exception types, not bare `except:`

```python
# ✅ Good - Specific exception, structured logging
try:
    result = process_data(data)
except ValueError as e:
    logger.error("Invalid data format", extra={"data_shape": data.shape, "error": str(e)})
    raise
except FileNotFoundError as e:
    logger.error("Required file not found", extra={"file_path": str(e)})
    raise

# ❌ Bad - Swallowing errors
try:
    result = process_data(data)
except:
    pass  # Silent failure!
```

## Comments

- **Why > What:** Comments explain the REASON, not the WHAT
- **TODO/FIXME:** Mark incomplete work with context
- **Complex logic:** Explain non-obvious algorithms or business rules

```python
# ✅ Good - Explains why
# Use smaller batch size for memory-constrained environments
# AzureML Standard_NC6 has 6GB RAM, so we limit to 16 samples
batch_size = 16 if compute_target.memory_gb < 8 else 32

# ❌ Bad - Explains what (obvious)
# Set batch_size to 16
batch_size = 16
```
