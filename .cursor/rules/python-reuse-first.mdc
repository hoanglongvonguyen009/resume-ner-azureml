---
name: python-reuse-first
description: Prefer reusing and extending existing modules over adding new ones.
globs:
  - "src/**/*.py"
  - "tests/**/*.py"
alwaysApply: true
---
## Reuse-first rules

Before creating any new:

- module/package in `src/`
- public function/class
- test module under `tests/`

the agent must:

- **Search for existing implementations**
  - Use symbol and text search in `src/` (e.g., grep / code search) for similar names/behavior.
- **Propose a reuse plan**
  - If an existing module is related, extend or refactor it instead of creating a new one.
- **Document the decision**
  - In the PR description or comments, briefly state:
  - "Existing options considered: `<modules>`”
  - "Reason new code was necessary: `<reason>`"
- Reuse-first does not justify large, risky refactors; prefer small extensions to existing modules over massive rewrites.

## Code Structure and Responsibility (SRP guardrails)

When refactoring or extending existing code:

- **SRP, pragmatically**: Keep each module/function focused on one clear responsibility, but avoid splitting into tiny wrappers that hide the main flow.
- **Split only with a trigger**:
- The code mixes concerns (e.g., IO + parsing + business logic + orchestration in one place), or
- A helper is reused by 2+ callers, or
- The function/module is becoming hard to scan (≈80+ lines or multiple unrelated branches).
- **Keep cohesion when it changes together**: If logic changes for the same reason and is used in one workflow step, keep it together (prefer small internal helpers over new files).
- **Remove dead paths carefully**: Delete redundant/unused branches only after repo search + tests show they're unused. Otherwise, deprecate (comment/TODO) instead of deleting.
- **No sweeping refactors**: Reuse-first + SRP does not justify large rewrites. Limit cleanup to the touched area needed for the change.
- **Decision note**: If you split or keep code together, add a 1–2 line note:
- "Kept in same module because …" / "Split because …"
